<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>IdeaBoard Pro - Sua Prancheta Criativa</title>

  <!-- Json manifest for mobile icon App -->
  <link rel="icon" type="image/x-icon" href="fav.png">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#000">

  <!-- √çcones - Boxicons + Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #8b5cf6;
      --success: #10b981;
      --danger: #ef4444;
      --warning: #f59e0b;
      --dark: #1f2937;
      --gray: #6b7280;
      --light: #f3f4f6;
      --white: #ffffff;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      height: 100vh;
      height: 100dvh; /* Dynamic viewport height for mobile */
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
      background: var(--white);
    }

    /* Header */
    header {
      background: var(--dark);
      color: var(--white);
      padding: 10px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
      position: relative;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .btn-back {
      background: transparent;
      border: 2px solid var(--primary);
      color: var(--primary);
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .btn-back:hover, .btn-back:active {
      background: var(--primary);
      color: var(--white);
      transform: translateX(-3px);
    }

    header h1 {
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    header h1 i {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 24px;
    }

    .header-center {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      justify-content: center;
    }

    .greeting {
      font-size: 15px;
      font-weight: 600;
      color: var(--white);
    }

    .datetime {
      font-size: 12px;
      color: #9ca3af;
      font-weight: 400;
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    .btn-header {
      padding: 8px 12px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.3s ease;
      background: transparent;
      border: 1px solid var(--primary);
      color: var(--white);
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }

    .btn-header:hover, .btn-header:active {
      background: var(--primary-dark);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }

    .btn-header i {
      font-size: 15px;
    }

    .btn-header .btn-text {
      display: inline;
    }

    /* Mobile Menu Toggle */
    .menu-toggle {
      display: none;
      background: var(--primary);
      color: var(--white);
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 20px;
    }

    /* Toolbar */
    #toolbar {
      background: var(--white);
      padding: 12px 15px;
      display: flex;
      gap: 15px;
      align-items: center;
      border-bottom: 2px solid var(--light);
      flex-wrap: wrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      transition: transform 0.3s ease;
      position: relative;
      z-index: 999;
    }

    #toolbar.mobile-hidden {
      transform: translateY(-100%);
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
    }

    .tool-group {
      display: flex;
      gap: 6px;
      padding: 6px;
      background: var(--light);
      border-radius: 10px;
      align-items: center;
      flex-shrink: 0;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      min-width: 40px;
      min-height: 40px;
      border: 2px solid transparent;
      background: var(--white);
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      position: relative;
      -webkit-tap-highlight-color: transparent;
    }

    .tool-btn i {
      font-size: 18px;
      color: var(--dark);
    }

    .tool-btn:active {
      transform: scale(0.95);
    }

    .tool-btn:hover {
      background: var(--primary);
      transform: scale(1.05);
    }

    .tool-btn:hover i {
      color: var(--white);
    }

    .tool-btn.active {
      background: var(--primary);
      border-color: var(--primary-dark);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    .tool-btn.active i {
      color: var(--white);
    }

    .color-picker {
      width: 40px;
      height: 40px;
      min-width: 40px;
      border: 3px solid var(--white);
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: transform 0.2s ease;
    }

    .color-picker:active {
      transform: scale(0.95);
    }

    .size-slider {
      width: 100px;
      height: 6px;
      border-radius: 3px;
      outline: none;
      background: linear-gradient(to right, var(--primary), var(--secondary));
    }

    #imageInput {
      display: none;
    }

    /* Canvas Container */
    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: #fafafa;
      background-image: 
        linear-gradient(rgba(0,0,0,.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,.03) 1px, transparent 1px);
      background-size: 20px 20px;
      touch-action: none;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      touch-action: none;
    }

    /* Images */
    .board-image {
      position: absolute;
      cursor: move;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border-radius: 8px;
      transition: box-shadow 0.2s ease;
      transform-origin: top left;
      touch-action: none;
    }

    .board-image:hover, .board-image:active {
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
      z-index: 10 !important;
    }

    .board-image img {
      display: block;
      border-radius: 8px;
      width: 100%;
      height: 100%;
      pointer-events: none;
      user-select: none;
    }

    .image-delete {
      position: absolute;
      top: -10px;
      right: -10px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--danger);
      color: var(--white);
      border: 2px solid var(--white);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      z-index: 100;
      opacity: 0.9;
    }

    .board-image:hover .image-delete,
    .board-image:active .image-delete {
      display: flex;
    }

    /* Resize Handles */
    .resize-handle {
      position: absolute;
      width: 16px;
      height: 16px;
      background: var(--primary);
      border: 2px solid var(--white);
      border-radius: 50%;
      display: flex;
      z-index: 100;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      opacity: 0.9;
    }

    .board-image:hover .resize-handle,
    .board-image:active .resize-handle {
      display: block;
    }

    .resize-handle.nw {
      top: -8px;
      left: -8px;
      cursor: nw-resize;
    }

    .resize-handle.ne {
      top: -8px;
      right: -8px;
      cursor: ne-resize;
    }

    .resize-handle.sw {
      bottom: -8px;
      left: -8px;
      cursor: sw-resize;
    }

    .resize-handle.se {
      bottom: -8px;
      right: -8px;
      cursor: se-resize;
    }

    /* Sticky Notes */
    .sticky-note {
      position: absolute;
      min-width: 180px;
      min-height: 120px;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      cursor: move;
      font-family: 'Segoe UI', sans-serif;
      font-size: 13px;
      line-height: 1.6;
      resize: both;
      overflow: auto;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      transform-origin: top left;
      touch-action: none;
    }

    .sticky-note:hover, .sticky-note:active {
      box-shadow: 0 6px 20px rgba(0,0,0,0.2);
      z-index: 10 !important;
    }

    .sticky-note textarea {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      font-family: inherit;
      font-size: inherit;
      resize: none;
      outline: none;
      color: #333;
    }

    .sticky-delete {
      position: absolute;
      top: -1px;
      right: -1px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--danger);
      color: var(--white);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      opacity: 0.9;
    }

    .sticky-note:hover .sticky-delete,
    .sticky-note:active .sticky-delete {
      display: flex;
    }

    /* Mind Map Node */
    .mindmap-node {
      position: absolute;
      padding: 10px 18px;
      background: var(--white);
      border: 3px solid var(--primary);
      border-radius: 20px;
      cursor: move;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
      transition: all 0.1s ease;
      min-width: 90px;
      text-align: center;
      transform-origin: center;
      user-select: none;
      touch-action: none;
    }

    .mindmap-node:hover, .mindmap-node:active {
      box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
      z-index: 10 !important;
    }

    .mindmap-node.root {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: var(--white);
      border: none;
      font-size: 16px;
      padding: 14px 25px;
    }

    .mindmap-node.child {
      background: var(--light);
    }

    .mindmap-text {
      outline: none;
      border: none;
      background: transparent;
      text-align: center;
      width: 100%;
      cursor: text;
      display: inline-block;
      padding: 3px;
    }

    .mindmap-controls {
      position: absolute;
      top: -12px;
      right: -12px;
      display: flex;
      gap: 4px;
      z-index: 10;
      opacity: 0.9;
    }

    .mindmap-node:hover .mindmap-controls,
    .mindmap-node:active .mindmap-controls {
      display: flex;
    }

    .mindmap-btn {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      color: var(--white);
      border: 2px solid var(--white);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }

    .mindmap-delete {
      background: var(--danger);
    }

    .mindmap-disconnect {
      background: var(--warning);
    }

    .mindmap-connect {
      background: var(--success);
    }

    .mindmap-color {
      background: var(--secondary);
    }

    /* Floating Panel */
    .floating-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--white);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 220px;
      max-width: 90vw;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .panel-header {
      font-weight: 700;
      font-size: 14px;
      padding: 12px 15px;
      color: var(--dark);
      border-bottom: 2px solid var(--light);
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      background: var(--light);
      -webkit-tap-highlight-color: transparent;
    }

    .panel-header:active {
      background: #e5e7eb;
    }

    .panel-title {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .panel-title i {
      color: var(--primary);
    }

    .panel-toggle {
      font-size: 18px;
      color: var(--gray);
      transition: transform 0.3s ease;
    }

    .panel-toggle.collapsed {
      transform: rotate(180deg);
    }

    .panel-content {
      padding: 15px;
      max-height: 350px;
      overflow-y: auto;
      transition: max-height 0.3s ease, padding 0.3s ease;
      font-size: 11px;
    }

    .panel-content.collapsed {
      max-height: 0;
      padding: 0 15px;
      overflow: hidden;
    }

    /* Responsive - Tablet */
    @media (max-width: 1024px) {
      header h1 { font-size: 18px; }
      .greeting { font-size: 14px; }
      .datetime { font-size: 11px; }
      .tool-btn { width: 38px; height: 38px; min-width: 38px; min-height: 38px; }
      .tool-btn i { font-size: 16px; }
      .color-picker { width: 38px; height: 38px; min-width: 38px; }
      .size-slider { width: 80px; }
      #toolbar { padding: 10px; gap: 12px; }
      .floating-panel { bottom: 15px; right: 15px; min-width: 200px; }
    }

    /* Responsive - Mobile */
    @media (max-width: 768px) {
      header {
        padding: 8px 10px;
      }

      .header-left {
        gap: 10px;
      }

      .btn-back {
        padding: 5px 8px;
        font-size: 12px;
      }

      header h1 {
        font-size: 16px;
      }

      header h1 i {
        font-size: 20px;
      }

      .header-center {
        flex-direction: column;
        gap: 2px;
        align-items: flex-start;
      }

      .greeting {
        font-size: 13px;
      }

      .datetime {
        font-size: 10px;
      }

      .menu-toggle {
        display: block;
      }

      .header-actions {
        display: none;
        position: absolute;
        top: 100%;
        right: 0;
        background: var(--dark);
        flex-direction: column;
        padding: 10px;
        gap: 8px;
        border-radius: 0 0 0 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        min-width: 150px;
      }

      .header-actions.show {
        display: flex;
      }

      .btn-header .btn-text {
        display: inline;
      }

      #toolbar {
        padding: 8px 10px;
        gap: 10px;
      }

      .tool-group {
        gap: 5px;
        padding: 5px;
      }

      .tool-btn {
        width: 36px;
        height: 36px;
        min-width: 36px;
        min-height: 36px;
      }

      .tool-btn i {
        font-size: 16px;
      }

      .color-picker {
        width: 36px;
        height: 36px;
        min-width: 36px;
      }

      .size-slider {
        width: 70px;
      }

      .floating-panel {
        bottom: 10px;
        right: 10px;
        left: 10px;
        min-width: auto;
      }

      .panel-content {
        font-size: 10px;
        line-height: 1.6;
      }

      .mindmap-node {
        min-width: 80px;
        padding: 8px 15px;
        font-size: 12px;
      }

      .mindmap-node.root {
        font-size: 14px;
        padding: 12px 20px;
      }

      .sticky-note {
        min-width: 150px;
        min-height: 100px;
        font-size: 12px;
      }
    }

    /* Responsive - Small Mobile */
    @media (max-width: 480px) {
      .btn-back span {
        display: none;
      }

      .tool-btn {
        width: 34px;
        height: 34px;
        min-width: 34px;
        min-height: 34px;
      }

      .color-picker {
        width: 34px;
        height: 34px;
        min-width: 34px;
      }

      .size-slider {
        width: 60px;
      }
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }

    .sticky-note, .mindmap-node, .board-image {
      animation: fadeIn 0.3s ease;
    }

    /* Selected Object Highlight */
    .selected-object {
      box-shadow: 0 0 0 3px var(--primary) !important;
    }

    /* Touch feedback */
    .touch-feedback {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(99, 102, 241, 0.3);
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0);
      animation: touchRipple 0.6s ease-out;
    }

    @keyframes touchRipple {
      to {
        transform: translate(-50%, -50%) scale(2);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="header-left">
        <button class="btn-back" onclick="window.location.href='https://wwww.filipeagenda.github.io'">
          <i class='bx bx-arrow-back'></i> <span>Voltar</span>
        </button>
        <h1><img src="favi.png" style="width: 25px;"> IdeaBoard Pro</h1>
      </div>
      
      <div class="header-center">
        <span class="greeting" id="greeting">Bem-vindo!</span>
        <span class="datetime" id="datetime">Carregando...</span>
      </div>

      <button class="menu-toggle" onclick="toggleMenu()" aria-label="Menu">
        <i class='bx bx-menu'></i>
      </button>

      <div class="header-actions" id="headerActions">
        <button class="btn-header" onclick="location.reload()"; closeMenu();"><i class='bx bx-refresh'></i> <span class="btn-text">Refresh</span></button>
        <button class="btn-header" onclick="saveBoard(); closeMenu();"><i class='bx bx-save'></i> <span class="btn-text">Salvar</span></button>
        <button class="btn-header" onclick="loadBoard(); closeMenu();"><i class='bx bx-folder-open'></i> <span class="btn-text">Carregar</span></button>
        <button class="btn-header" onclick="exportImage(); closeMenu();"><i class='bx bx-image'></i> <span class="btn-text">Exportar</span></button>
        <button class="btn-header" onclick="clearAll(); closeMenu();"><i class='bx bx-trash'></i> <span class="btn-text">Limpar</span></button>
      </div>
    </header>

    <div id="toolbar">
      <div class="tool-group">
        <button class="tool-btn active" data-tool="pen" title="Caneta" onclick="setTool('pen')">
          <i class='bx bx-pencil'></i>
        </button>
        <button class="tool-btn" data-tool="highlighter" title="Marca-texto" onclick="setTool('highlighter')">
          <i class='bx bx-highlight'></i>
        </button>
        <button class="tool-btn" data-tool="eraser" title="Borracha" onclick="setTool('eraser')">
          <i class='bx bx-eraser'></i>
        </button>
        <button class="tool-btn" data-tool="line" title="Linha" onclick="setTool('line')">
          <i class='bx bx-minus'></i>
        </button>
      </div>

      <div class="tool-group">
        <button class="tool-btn" data-tool="rectangle" title="Ret√¢ngulo" onclick="setTool('rectangle')">
          <i class='bx bx-rectangle'></i>
        </button>
        <button class="tool-btn" data-tool="circle" title="C√≠rculo" onclick="setTool('circle')">
          <i class='bx bx-circle'></i>
        </button>
        <button class="tool-btn" data-tool="arrow" title="Seta" onclick="setTool('arrow')">
          <i class='bx bx-right-arrow-alt'></i>
        </button>
        <button class="tool-btn" data-tool="text" title="Texto" onclick="setTool('text')">
          <i class='bx bx-text'></i>
        </button>
      </div>

      <div class="tool-group">
        <button class="tool-btn" data-tool="sticky" title="Sticky Note" onclick="setTool('sticky')">
          <i class='bx bxs-note'></i>
        </button>
        <button class="tool-btn" data-tool="mindmap" title="Mind Map" onclick="setTool('mindmap')">
          <i class='bx bx-network-chart'></i>
        </button>
        <button class="tool-btn" data-tool="image" title="Imagem" onclick="addImage()">
          <i class='bx bx-image-add'></i>
        </button>
        <button class="tool-btn" data-tool="select" title="Selecionar" onclick="setTool('select')">
          <i class='bx bx-pointer'></i>
        </button>
      </div>

      <div class="tool-group">
        <input type="color" class="color-picker" id="colorPicker" value="#333333" title="Cor">
        <input type="range" class="size-slider" id="sizeSlider" min="1" max="20" value="3" title="Espessura">
      </div>

      <div class="tool-group">
        <button class="tool-btn" onclick="undo()" title="Desfazer">
          <i class='bx bx-undo'></i>
        </button>
        <button class="tool-btn" onclick="redo()" title="Refazer">
          <i class='bx bx-redo'></i>
        </button>
        <button class="tool-btn" onclick="zoomIn()" title="Zoom +">
          <i class='bx bx-zoom-in'></i>
        </button>
        <button class="tool-btn" onclick="zoomOut()" title="Zoom -">
          <i class='bx bx-zoom-out'></i>
        </button>
      </div>
    </div>

    <div id="canvas-container">
      <canvas id="canvas"></canvas>
      <svg id="connections-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></svg>
    </div>

    <input type="file" id="imageInput" accept="image/*" style="display: none;">

    <div class="floating-panel">
      <div class="panel-header" onclick="togglePanel()">
        <div class="panel-title">
          <i class='bx bx-keyboard'></i>
          <span>Atalhos</span>
        </div>
        <i class='bx bx-chevron-down panel-toggle' id="panelToggle"></i>
      </div>
      <div class="panel-content collapsed" id="panelContent">
        <div style="color: var(--gray); line-height: 1.8;">
          <strong>P</strong> - Caneta<br>
          <strong>E</strong> - Borracha<br>
          <strong>S</strong> - Sticky Note<br>
          <strong>M</strong> - Mind Map<br>
          <strong>I</strong> - Imagem<br>
          <strong>V</strong> - Selecionar<br>
          <strong>Del</strong> - Deletar<br>
          <strong>Ctrl+Z</strong> - Desfazer<br>
          <strong>Ctrl+Y</strong> - Refazer<br>
          <strong>2 dedos</strong> - Pan/Zoom<br>
          <strong>üîó</strong> - Conectar<br>
          <strong>‚ö†Ô∏è</strong> - Desvincular<br>
          <strong>üéØ</strong> - Arraste cantos para redimensionar
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== CONFIGURA√á√ÉO INICIAL =====
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const connectionsSvg = document.getElementById('connections-svg');
    const imageInput = document.getElementById('imageInput');
    
    let currentTool = 'pen';
    let isDrawing = false;
    let isPanning = false;
    let startX, startY, lastX, lastY;
    let currentColor = '#333333';
    let currentSize = 3;
    let objects = [];
    let history = [];
    let historyStep = -1;
    let zoom = 1;
    let panX = 0, panY = 0;
    let tempShape = null;
    let selectedObject = null;
    let selectedObjectIndex = -1;
    let dragOffsetX = 0, dragOffsetY = 0;
    let stickyNoteCount = 0;
    let mindmapNodes = [];
    let mindmapConnections = [];
    let boardImages = [];
    let isConnecting = false;
    let connectingFrom = null;
    let isResizing = false;
    let resizingImage = null;
    let resizeHandle = null;
    let resizeStartWidth = 0;
    let resizeStartHeight = 0;
    let resizeStartX = 0;
    let resizeStartY = 0;
    
    // Touch support
    let touches = {};
    let lastTouchDistance = 0;
    let lastPinchZoom = 1;

    const stickyColors = ['#fef08a', '#fecaca', '#bfdbfe', '#bbf7d0', '#ddd6fe', '#fed7aa'];
    const nodeColors = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#3b82f6', '#ef4444'];

    // Detect mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // ===== MOBILE MENU =====
    function toggleMenu() {
      const menu = document.getElementById('headerActions');
      menu.classList.toggle('show');
    }

    function closeMenu() {
      const menu = document.getElementById('headerActions');
      menu.classList.remove('show');
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
      const menu = document.getElementById('headerActions');
      const toggle = document.querySelector('.menu-toggle');
      if (menu.classList.contains('show') && !menu.contains(e.target) && !toggle.contains(e.target)) {
        closeMenu();
      }
    });

    // ===== SAUDA√á√ÉO E DATA/HORA =====
    function updateDateTime() {
      const now = new Date();
      const hours = now.getHours();
      
      let greeting;
      if (hours < 12) {
        greeting = 'Bom dia!';
      } else if (hours < 18) {
        greeting = 'Boa tarde!';
      } else {
        greeting = 'Boa noite!';
      }
      
      const months = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho', 
                      'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];
      const day = now.getDate();
      const month = months[now.getMonth()];
      const year = now.getFullYear();
      const time = now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
      
      document.getElementById('greeting').textContent = greeting + ' ';
      document.getElementById('datetime').textContent = `${day} ${month} ${year} - ${time}`;
    }

    setInterval(updateDateTime, 1000);
    updateDateTime();

    // ===== PAINEL FLUTUANTE =====
    function togglePanel() {
      const content = document.getElementById('panelContent');
      const toggle = document.getElementById('panelToggle');
      content.classList.toggle('collapsed');
      toggle.classList.toggle('collapsed');
    }

    // ===== INICIALIZA√á√ÉO =====
    function init() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      setupEventListeners();
      addToHistory();
      
      // Prevent default touch behaviors
      document.body.addEventListener('touchmove', (e) => {
        if (e.target === canvas || container.contains(e.target)) {
          e.preventDefault();
        }
      }, { passive: false });
    }

    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = rect.width * (window.devicePixelRatio || 2);
      canvas.height = rect.height * (window.devicePixelRatio || 2);
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.scale(window.devicePixelRatio || 2, window.devicePixelRatio || 2);
      redraw();
    }

    // ===== FERRAMENTAS =====
    function setTool(tool) {
      currentTool = tool;
      selectedObject = null;
      selectedObjectIndex = -1;
      
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
        if(btn.getAttribute('data-tool') === tool) {
          btn.classList.add('active');
        }
      });
      
      if(tool === 'select') {
        canvas.style.cursor = 'default';
      } else if(tool === 'eraser') {
        canvas.style.cursor = 'grab';
      } else {
        canvas.style.cursor = 'crosshair';
      }
      
      redraw();
    }

    // ===== ADICIONAR IMAGEM =====
    function addImage() {
      imageInput.click();
    }

    imageInput.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if(file && file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = function(event) {
          const defaultWidth = Math.min(300, window.innerWidth * 0.6);
          createBoardImage(event.target.result, 100, 100, defaultWidth, defaultWidth * 0.75);
        };
        reader.readAsDataURL(file);
      }
    });

    function createBoardImage(src, x, y, width, height) {
      const imgContainer = document.createElement('div');
      imgContainer.className = 'board-image';
      imgContainer.style.left = x + 'px';
      imgContainer.style.top = y + 'px';
      imgContainer.style.width = width + 'px';
      imgContainer.style.height = height + 'px';
      imgContainer.style.zIndex = 100 + boardImages.length;
      imgContainer.style.transform = `scale(${zoom})`;

      const img = document.createElement('img');
      img.src = src;
      imgContainer.appendChild(img);

      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'image-delete';
      deleteBtn.innerHTML = '√ó';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        const index = boardImages.indexOf(imgContainer);
        if(index > -1) boardImages.splice(index, 1);
        imgContainer.remove();
      };
      imgContainer.appendChild(deleteBtn);

      // Criar handles de resize
      const handles = ['nw', 'ne', 'sw', 'se'];
      handles.forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        handle.dataset.position = pos;
        
        handle.addEventListener('mousedown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          startImageResize(e, imgContainer, pos);
        });
        
        handle.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          e.preventDefault();
          const touch = e.touches[0];
          startImageResize(touch, imgContainer, pos);
        }, { passive: false });
        
        imgContainer.appendChild(handle);
      });

      makeImageDraggable(imgContainer);
      container.appendChild(imgContainer);
      boardImages.push(imgContainer);
    }

    // ===== RESIZE DE IMAGEM =====
    function startImageResize(e, imgContainer, handle) {
      isResizing = true;
      resizingImage = imgContainer;
      resizeHandle = handle;
      resizeStartWidth = imgContainer.offsetWidth;
      resizeStartHeight = imgContainer.offsetHeight;
      resizeStartX = e.clientX || e.pageX;
      resizeStartY = e.clientY || e.pageY;
      
      document.addEventListener('mousemove', handleImageResize);
      document.addEventListener('mouseup', stopImageResize);
      document.addEventListener('touchmove', handleImageResizeTouch, { passive: false });
      document.addEventListener('touchend', stopImageResize);
    }

    function handleImageResize(e) {
      if(!isResizing || !resizingImage) return;
      
      const deltaX = e.clientX - resizeStartX;
      const deltaY = e.clientY - resizeStartY;
      
      applyResize(deltaX, deltaY);
    }

    function handleImageResizeTouch(e) {
      e.preventDefault();
      if(!isResizing || !resizingImage) return;
      
      const touch = e.touches[0];
      const deltaX = touch.clientX - resizeStartX;
      const deltaY = touch.clientY - resizeStartY;
      
      applyResize(deltaX, deltaY);
    }

    function applyResize(deltaX, deltaY) {
      let newWidth = resizeStartWidth;
      let newHeight = resizeStartHeight;
      let newLeft = parseInt(resizingImage.style.left);
      let newTop = parseInt(resizingImage.style.top);
      
      if(resizeHandle === 'se') {
        newWidth = Math.max(50, resizeStartWidth + deltaX);
        newHeight = Math.max(50, resizeStartHeight + deltaY);
      } else if(resizeHandle === 'sw') {
        newWidth = Math.max(50, resizeStartWidth - deltaX);
        newHeight = Math.max(50, resizeStartHeight + deltaY);
        if(newWidth > 50) {
          newLeft = parseInt(resizingImage.style.left) + deltaX;
        }
      } else if(resizeHandle === 'ne') {
        newWidth = Math.max(50, resizeStartWidth + deltaX);
        newHeight = Math.max(50, resizeStartHeight - deltaY);
        if(newHeight > 50) {
          newTop = parseInt(resizingImage.style.top) + deltaY;
        }
      } else if(resizeHandle === 'nw') {
        newWidth = Math.max(50, resizeStartWidth - deltaX);
        newHeight = Math.max(50, resizeStartHeight - deltaY);
        if(newWidth > 50) {
          newLeft = parseInt(resizingImage.style.left) + deltaX;
        }
        if(newHeight > 50) {
          newTop = parseInt(resizingImage.style.top) + deltaY;
        }
      }
      
      resizingImage.style.width = newWidth + 'px';
      resizingImage.style.height = newHeight + 'px';
      resizingImage.style.left = newLeft + 'px';
      resizingImage.style.top = newTop + 'px';
    }

    function stopImageResize() {
      isResizing = false;
      resizingImage = null;
      resizeHandle = null;
      document.removeEventListener('mousemove', handleImageResize);
      document.removeEventListener('mouseup', stopImageResize);
      document.removeEventListener('touchmove', handleImageResizeTouch);
      document.removeEventListener('touchend', stopImageResize);
    }

    // ===== EVENT LISTENERS =====
    function setupEventListeners() {
      document.getElementById('colorPicker').addEventListener('change', (e) => {
        currentColor = e.target.value;
      });

      document.getElementById('sizeSlider').addEventListener('input', (e) => {
        currentSize = parseInt(e.target.value);
      });

      // Mouse events
      canvas.addEventListener('mousedown', handleMouseDown);
      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseup', handleMouseUp);
      canvas.addEventListener('wheel', handleWheel, { passive: false });

      // Touch events
      canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
      canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

      document.addEventListener('keydown', handleKeyDown);
    }

    function handleTouchStart(e) {
      e.preventDefault();
      
      if(e.touches.length === 2) {
        // Two finger gesture - pinch zoom
        isPanning = true;
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        lastTouchDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        lastPinchZoom = zoom;
        return;
      }
      
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY,
        button: 0
      });
      canvas.dispatchEvent(mouseEvent);
      
      // Visual feedback
      showTouchFeedback(touch.clientX, touch.clientY);
    }

    function handleTouchMove(e) {
      e.preventDefault();
      
      if(e.touches.length === 2) {
        // Pinch zoom
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const distance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        );
        
        if(lastTouchDistance > 0) {
          const scale = distance / lastTouchDistance;
          zoom = Math.max(0.5, Math.min(3, lastPinchZoom * scale));
          updateZoomTransform();
          redraw();
        }
        return;
      }
      
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      canvas.dispatchEvent(mouseEvent);
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      
      if(e.touches.length === 0) {
        isPanning = false;
        lastTouchDistance = 0;
        const mouseEvent = new MouseEvent('mouseup', {
          clientX: 0,
          clientY: 0
        });
        canvas.dispatchEvent(mouseEvent);
      }
    }

    function showTouchFeedback(x, y) {
      const feedback = document.createElement('div');
      feedback.className = 'touch-feedback';
      feedback.style.left = x + 'px';
      feedback.style.top = y + 'px';
      document.body.appendChild(feedback);
      setTimeout(() => feedback.remove(), 600);
    }

    function handleMouseDown(e) {
      if(isResizing) return;
      
      const rect = canvas.getBoundingClientRect();
      startX = (e.clientX - rect.left - panX) / zoom;
      startY = (e.clientY - rect.top - panY) / zoom;
      lastX = startX;
      lastY = startY;

      if(e.button === 1 || (e.button === 0 && e.shiftKey)) {
        isPanning = true;
        canvas.style.cursor = 'grabbing';
        return;
      }

      if(currentTool === 'select') {
        selectedObjectIndex = findObjectAt(startX, startY);
        if(selectedObjectIndex !== -1) {
          selectedObject = objects[selectedObjectIndex];
          const bounds = getObjectBounds(selectedObject);
          dragOffsetX = startX - bounds.x;
          dragOffsetY = startY - bounds.y;
          isDrawing = true;
          redraw();
          return;
        }
      }

      isDrawing = true;

      if(currentTool === 'sticky') {
        createStickyNote(e.clientX - rect.left, e.clientY - rect.top);
        isDrawing = false;
        return;
      }

      if(currentTool === 'mindmap') {
        createMindmapNode(e.clientX - rect.left, e.clientY - rect.top);
        isDrawing = false;
        return;
      }

      if(currentTool === 'pen' || currentTool === 'highlighter') {
        objects.push({
          type: currentTool,
          points: [[startX, startY]],
          color: currentColor,
          size: currentSize,
          opacity: currentTool === 'highlighter' ? 0.3 : 1
        });
      } else if(currentTool === 'text') {
        const text = prompt('Digite o texto:');
        if(text) {
          objects.push({
            type: 'text',
            x: startX,
            y: startY,
            text: text,
            color: currentColor,
            size: currentSize * 5
          });
          addToHistory();
          redraw();
        }
        isDrawing = false;
      }
    }

    function handleMouseMove(e) {
      if(isResizing) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left - panX) / zoom;
      const y = (e.clientY - rect.top - panY) / zoom;

      if(isPanning && e.touches && e.touches.length !== 2) {
        panX += e.movementX;
        panY += e.movementY;
        updateZoomTransform();
        redraw();
        return;
      }

      if(!isDrawing) return;

      if(currentTool === 'select' && selectedObject) {
        moveObject(selectedObject, x - dragOffsetX, y - dragOffsetY);
        redraw();
        return;
      }

      if(currentTool === 'pen' || currentTool === 'highlighter') {
        objects[objects.length - 1].points.push([x, y]);
        redraw();
      } else if(currentTool === 'eraser') {
        eraseAt(x, y);
      } else if(['line', 'rectangle', 'circle', 'arrow'].includes(currentTool)) {
        tempShape = {
          type: currentTool,
          startX: startX,
          startY: startY,
          endX: x,
          endY: y,
          color: currentColor,
          size: currentSize
        };
        redraw();
      }

      lastX = x;
      lastY = y;
    }

    function handleMouseUp(e) {
      if(isResizing) return;
      
      if(isPanning) {
        isPanning = false;
        canvas.style.cursor = currentTool === 'eraser' ? 'grab' : (currentTool === 'select' ? 'default' : 'crosshair');
        return;
      }

      if(!isDrawing) return;
      isDrawing = false;

      if(currentTool === 'select' && selectedObject) {
        addToHistory();
      }

      if(tempShape) {
        objects.push({...tempShape});
        tempShape = null;
        addToHistory();
        redraw();
      } else if(currentTool === 'pen' || currentTool === 'highlighter') {
        addToHistory();
      }
    }

    function handleWheel(e) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoom *= delta;
      zoom = Math.max(0.5, Math.min(3, zoom));
      updateZoomTransform();
      redraw();
    }

    function handleKeyDown(e) {
      if(e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
      } else if(e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        redo();
      } else if(e.key === 'Delete') {
        if(selectedObjectIndex !== -1) {
          objects.splice(selectedObjectIndex, 1);
          selectedObject = null;
          selectedObjectIndex = -1;
          addToHistory();
          redraw();
        }
      } else {
        const toolMap = {
          'p': 'pen', 'e': 'eraser', 's': 'sticky', 
          'm': 'mindmap', 'v': 'select', 'l': 'line',
          'r': 'rectangle', 'c': 'circle', 't': 'text',
          'h': 'highlighter', 'a': 'arrow', 'i': 'image'
        };
        if(toolMap[e.key.toLowerCase()]) {
          if(e.key.toLowerCase() === 'i') {
            addImage();
          } else {
            setTool(toolMap[e.key.toLowerCase()]);
          }
        }
      }
    }

    // ===== SELE√á√ÉO E MOVIMENTO DE OBJETOS =====
    function findObjectAt(x, y) {
      for(let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if(isPointInObject(x, y, obj)) {
          return i;
        }
      }
      return -1;
    }

    function isPointInObject(x, y, obj) {
      const threshold = isMobile ? 15 : 10;
      
      if(obj.type === 'pen' || obj.type === 'highlighter') {
        return obj.points.some(pt => 
          Math.sqrt(Math.pow(pt[0] - x, 2) + Math.pow(pt[1] - y, 2)) < threshold
        );
      } else if(obj.type === 'text') {
        const bounds = getObjectBounds(obj);
        return x >= bounds.x && x <= bounds.x + bounds.width &&
               y >= bounds.y - bounds.height && y <= bounds.y;
      } else if(obj.type === 'rectangle') {
        const minX = Math.min(obj.startX, obj.endX);
        const maxX = Math.max(obj.startX, obj.endX);
        const minY = Math.min(obj.startY, obj.endY);
        const maxY = Math.max(obj.startY, obj.endY);
        return x >= minX && x <= maxX && y >= minY && y <= maxY;
      } else if(obj.type === 'circle') {
        const radius = Math.sqrt(Math.pow(obj.endX - obj.startX, 2) + Math.pow(obj.endY - obj.startY, 2));
        const dist = Math.sqrt(Math.pow(x - obj.startX, 2) + Math.pow(y - obj.startY, 2));
        return dist <= radius;
      } else if(obj.type === 'line' || obj.type === 'arrow') {
        const dist = distanceToLineSegment(x, y, obj.startX, obj.startY, obj.endX, obj.endY);
        return dist < threshold;
      }
      return false;
    }

    function distanceToLineSegment(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      if (lenSq != 0) param = dot / lenSq;
      let xx, yy;
      if (param < 0) {
        xx = x1; yy = y1;
      } else if (param > 1) {
        xx = x2; yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      const dx = px - xx;
      const dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function getObjectBounds(obj) {
      if(obj.type === 'text') {
        ctx.font = `${obj.size}px Arial`;
        const metrics = ctx.measureText(obj.text);
        return { x: obj.x, y: obj.y, width: metrics.width, height: obj.size };
      } else if(obj.type === 'pen' || obj.type === 'highlighter') {
        const xs = obj.points.map(p => p[0]);
        const ys = obj.points.map(p => p[1]);
        return {
          x: Math.min(...xs),
          y: Math.min(...ys),
          width: Math.max(...xs) - Math.min(...xs),
          height: Math.max(...ys) - Math.min(...ys)
        };
      } else if(obj.type === 'rectangle') {
        return {
          x: Math.min(obj.startX, obj.endX),
          y: Math.min(obj.startY, obj.endY),
          width: Math.abs(obj.endX - obj.startX),
          height: Math.abs(obj.endY - obj.startY)
        };
      } else if(obj.type === 'circle') {
        const radius = Math.sqrt(Math.pow(obj.endX - obj.startX, 2) + Math.pow(obj.endY - obj.startY, 2));
        return {
          x: obj.startX - radius,
          y: obj.startY - radius,
          width: radius * 2,
          height: radius * 2
        };
      } else if(obj.type === 'line' || obj.type === 'arrow') {
        return {
          x: Math.min(obj.startX, obj.endX),
          y: Math.min(obj.startY, obj.endY),
          width: Math.abs(obj.endX - obj.startX),
          height: Math.abs(obj.endY - obj.startY)
        };
      }
      return { x: 0, y: 0, width: 0, height: 0 };
    }

    function moveObject(obj, newX, newY) {
      const bounds = getObjectBounds(obj);
      const deltaX = newX - bounds.x;
      const deltaY = newY - bounds.y;

      if(obj.type === 'pen' || obj.type === 'highlighter') {
        obj.points = obj.points.map(([x, y]) => [x + deltaX, y + deltaY]);
      } else if(obj.type === 'text') {
        obj.x = newX;
        obj.y = newY;
      } else if(obj.type === 'rectangle' || obj.type === 'circle' || obj.type === 'line' || obj.type === 'arrow') {
        obj.startX += deltaX;
        obj.startY += deltaY;
        obj.endX += deltaX;
        obj.endY += deltaY;
      }
    }

    // ===== ZOOM TRANSFORM =====
    function updateZoomTransform() {
      document.querySelectorAll('.sticky-note, .mindmap-node, .board-image').forEach(element => {
        element.style.transform = `scale(${zoom})`;
      });
    }

    // ===== DESENHO =====
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(panX, panY);
      ctx.scale(zoom, zoom);

      for(let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        const isSelected = (i === selectedObjectIndex);
        drawObject(obj, false, isSelected);
      }

      if(tempShape) {
        drawObject(tempShape, true, false);
      }

      ctx.restore();
      
      drawMindmapConnections();
    }

    function drawObject(obj, isTemp = false, isSelected = false) {
      ctx.save();
      ctx.strokeStyle = obj.color || currentColor;
      ctx.fillStyle = obj.color || currentColor;
      ctx.lineWidth = obj.size || currentSize;
      ctx.globalAlpha = obj.opacity || 1;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if(isSelected) {
        ctx.shadowColor = '#6366f1';
        ctx.shadowBlur = 15;
      }

      if(obj.type === 'pen' || obj.type === 'highlighter') {
        ctx.beginPath();
        ctx.moveTo(obj.points[0][0], obj.points[0][1]);
        for(const pt of obj.points) {
          ctx.lineTo(pt[0], pt[1]);
        }
        ctx.stroke();
      } else if(obj.type === 'line') {
        ctx.beginPath();
        ctx.moveTo(obj.startX, obj.startY);
        ctx.lineTo(obj.endX, obj.endY);
        ctx.stroke();
      } else if(obj.type === 'rectangle') {
        const w = obj.endX - obj.startX;
        const h = obj.endY - obj.startY;
        if(isTemp) ctx.setLineDash([5, 5]);
        ctx.strokeRect(obj.startX, obj.startY, w, h);
        ctx.setLineDash([]);
      } else if(obj.type === 'circle') {
        const radius = Math.sqrt(Math.pow(obj.endX - obj.startX, 2) + Math.pow(obj.endY - obj.startY, 2));
        ctx.beginPath();
        ctx.arc(obj.startX, obj.startY, radius, 0, Math.PI * 2);
        if(isTemp) ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      } else if(obj.type === 'arrow') {
        drawArrow(obj.startX, obj.startY, obj.endX, obj.endY);
      } else if(obj.type === 'text') {
        ctx.font = `${obj.size}px Arial`;
        ctx.fillText(obj.text, obj.x, obj.y);
      }

      ctx.restore();
    }

    function drawArrow(x1, y1, x2, y2) {
      const headLen = 15;
      const angle = Math.atan2(y2 - y1, x2 - x1);
      
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
      ctx.stroke();
    }

    function eraseAt(x, y) {
      objects = objects.filter(obj => {
        if(obj.type === 'pen' || obj.type === 'highlighter') {
          return !obj.points.some(pt => 
            Math.sqrt(Math.pow(pt[0] - x, 2) + Math.pow(pt[1] - y, 2)) < 10
          );
        }
        return true;
      });
      redraw();
    }

    // ===== STICKY NOTES =====
    function createStickyNote(x, y) {
      const color = stickyColors[Math.floor(Math.random() * stickyColors.length)];
      const sticky = document.createElement('div');
      sticky.className = 'sticky-note';
      sticky.style.left = x + 'px';
      sticky.style.top = y + 'px';
      sticky.style.background = color;
      sticky.style.zIndex = 100 + stickyNoteCount++;
      sticky.style.transform = `scale(${zoom})`;

      const textarea = document.createElement('textarea');
      textarea.placeholder = 'Digite aqui...';
      sticky.appendChild(textarea);

      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'sticky-delete';
      deleteBtn.innerHTML = '√ó';
      deleteBtn.onclick = () => sticky.remove();
      sticky.appendChild(deleteBtn);

      makeDraggable(sticky);
      container.appendChild(sticky);
      textarea.focus();
    }

    // ===== MIND MAP =====
    function createMindmapNode(x, y) {
      const isRoot = mindmapNodes.length === 0;
      const node = document.createElement('div');
      node.className = 'mindmap-node ' + (isRoot ? 'root' : 'child');
      node.style.left = x + 'px';
      node.style.top = y + 'px';
      node.style.zIndex = 100 + mindmapNodes.length;
      node.style.transform = `scale(${zoom})`;
      node.dataset.nodeId = 'node_' + Date.now() + '_' + Math.random();
      
      if(!isRoot) {
        const randomColor = nodeColors[Math.floor(Math.random() * nodeColors.length)];
        node.style.borderColor = randomColor;
      }
      
      const textSpan = document.createElement('span');
      textSpan.className = 'mindmap-text';
      textSpan.contentEditable = true;
      textSpan.innerText = isRoot ? 'Ideia Central' : 'N√≥ ' + mindmapNodes.length;
      node.appendChild(textSpan);

      const controls = document.createElement('div');
      controls.className = 'mindmap-controls';
      
      const colorBtn = document.createElement('div');
      colorBtn.className = 'mindmap-btn mindmap-color';
      colorBtn.innerHTML = 'üé®';
      colorBtn.title = 'Mudar cor';
      colorBtn.onclick = (e) => {
        e.stopPropagation();
        const color = nodeColors[Math.floor(Math.random() * nodeColors.length)];
        node.style.borderColor = color;
        drawMindmapConnections();
      };
      
      const connectBtn = document.createElement('div');
      connectBtn.className = 'mindmap-btn mindmap-connect';
      connectBtn.innerHTML = 'üîó';
      connectBtn.title = 'Conectar';
      connectBtn.onclick = (e) => {
        e.stopPropagation();
        if(!isConnecting) {
          isConnecting = true;
          connectingFrom = node.dataset.nodeId;
          connectBtn.style.background = '#ef4444';
          alert('Clique no bot√£o üîó de outro n√≥ para criar a conex√£o');
        } else {
          if(connectingFrom !== node.dataset.nodeId) {
            mindmapConnections.push({ from: connectingFrom, to: node.dataset.nodeId });
            drawMindmapConnections();
          }
          isConnecting = false;
          connectingFrom = null;
          document.querySelectorAll('.mindmap-connect').forEach(btn => {
            btn.style.background = '#10b981';
          });
        }
      };
      
      const disconnectBtn = document.createElement('div');
      disconnectBtn.className = 'mindmap-btn mindmap-disconnect';
      disconnectBtn.innerHTML = '‚ö†Ô∏è';
      disconnectBtn.title = 'Desvincular todas conex√µes';
      disconnectBtn.onclick = (e) => {
        e.stopPropagation();
        mindmapConnections = mindmapConnections.filter(c => 
          c.from !== node.dataset.nodeId && c.to !== node.dataset.nodeId
        );
        drawMindmapConnections();
      };
      
      const deleteBtn = document.createElement('div');
      deleteBtn.className = 'mindmap-btn mindmap-delete';
      deleteBtn.innerHTML = '√ó';
      deleteBtn.title = 'Deletar';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        const index = mindmapNodes.indexOf(node);
        if(index > -1) {
          mindmapNodes.splice(index, 1);
          mindmapConnections = mindmapConnections.filter(c => 
            c.from !== node.dataset.nodeId && c.to !== node.dataset.nodeId
          );
          drawMindmapConnections();
        }
        node.remove();
      };
      
      controls.appendChild(colorBtn);
      controls.appendChild(connectBtn);
      controls.appendChild(disconnectBtn);
      controls.appendChild(deleteBtn);
      node.appendChild(controls);

      makeDraggable(node, () => drawMindmapConnections());
      container.appendChild(node);
      mindmapNodes.push(node);

      if(!isMobile) {
        setTimeout(() => {
          textSpan.focus();
          const range = document.createRange();
          const sel = window.getSelection();
          range.selectNodeContents(textSpan);
          sel.removeAllRanges();
          sel.addRange(range);
        }, 100);
      }
    }

    function drawMindmapConnections() {
      connectionsSvg.innerHTML = '';
      
      for(const conn of mindmapConnections) {
        const fromNode = mindmapNodes.find(n => n.dataset.nodeId === conn.from);
        const toNode = mindmapNodes.find(n => n.dataset.nodeId === conn.to);
        
        if(!fromNode || !toNode) continue;
        
        const fromRect = fromNode.getBoundingClientRect();
        const toRect = toNode.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        const x1 = fromRect.left + fromRect.width / 2 - containerRect.left;
        const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
        const x2 = toRect.left + toRect.width / 2 - containerRect.left;
        const y2 = toRect.top + toRect.height / 2 - containerRect.top;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const cpx = (x1 + x2) / 2;
        const cpy = y1;
        path.setAttribute('d', `M ${x1} ${y1} Q ${cpx} ${cpy} ${x2} ${y2}`);
        path.setAttribute('stroke', fromNode.style.borderColor || '#6366f1');
        path.setAttribute('stroke-width', '3');
        path.setAttribute('fill', 'none');
        connectionsSvg.appendChild(path);
      }
    }

    // ===== DRAG AND DROP =====
    function makeDraggable(element, onMove = null) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      let isDragging = false;
      
      element.addEventListener('mousedown', dragMouseDown);
      element.addEventListener('touchstart', dragTouchStart, { passive: false });

      function dragMouseDown(e) {
        if(e.target.tagName === 'TEXTAREA' || e.target.className === 'mindmap-text') {
          return;
        }
        
        if(e.target.className && e.target.className.includes('mindmap-btn')) {
          return;
        }

        if(e.target.className && (e.target.className.includes('image-delete') || e.target.className.includes('sticky-delete'))) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        isDragging = true;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        document.addEventListener('mouseup', closeDragElement);
        document.addEventListener('mousemove', elementDrag);
      }

      function dragTouchStart(e) {
        if(e.target.tagName === 'TEXTAREA' || e.target.className === 'mindmap-text') {
          return;
        }
        
        if(e.target.className && e.target.className.includes('mindmap-btn')) {
          return;
        }

        if(e.target.className && (e.target.className.includes('image-delete') || e.target.className.includes('sticky-delete'))) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        
        const touch = e.touches[0];
        isDragging = true;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        
        document.addEventListener('touchend', closeDragElement);
        document.addEventListener('touchmove', elementDragTouch, { passive: false });
      }

      function elementDrag(e) {
        if(!isDragging) return;
        
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
        
        if(onMove) onMove();
      }

      function elementDragTouch(e) {
        if(!isDragging) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        pos1 = pos3 - touch.clientX;
        pos2 = pos4 - touch.clientY;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
        
        if(onMove) onMove();
      }

      function closeDragElement() {
        isDragging = false;
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', closeDragElement);
        document.removeEventListener('touchmove', elementDragTouch);
      }
    }

    function makeImageDraggable(element) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      let isDragging = false;
      
      element.addEventListener('mousedown', dragMouseDown);
      element.addEventListener('touchstart', dragTouchStart, { passive: false });

      function dragMouseDown(e) {
        if(e.target.className && e.target.className.includes('resize-handle')) {
          return;
        }
        
        if(e.target.className && e.target.className.includes('image-delete')) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        isDragging = true;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        document.addEventListener('mouseup', closeDragElement);
        document.addEventListener('mousemove', elementDrag);
      }

      function dragTouchStart(e) {
        if(e.target.className && e.target.className.includes('resize-handle')) {
          return;
        }
        
        if(e.target.className && e.target.className.includes('image-delete')) {
          return;
        }
        
        e.preventDefault();
        e.stopPropagation();
        
        const touch = e.touches[0];
        isDragging = true;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        
        document.addEventListener('touchend', closeDragElement);
        document.addEventListener('touchmove', elementDragTouch, { passive: false });
      }

      function elementDrag(e) {
        if(!isDragging) return;
        
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
      }

      function elementDragTouch(e) {
        if(!isDragging) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        pos1 = pos3 - touch.clientX;
        pos2 = pos4 - touch.clientY;
        pos3 = touch.clientX;
        pos4 = touch.clientY;
        
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
      }

      function closeDragElement() {
        isDragging = false;
        document.removeEventListener('mouseup', closeDragElement);
        document.removeEventListener('mousemove', elementDrag);
        document.removeEventListener('touchend', closeDragElement);
        document.removeEventListener('touchmove', elementDragTouch);
      }
    }

    // ===== HIST√ìRICO =====
    function addToHistory() {
      historyStep++;
      history = history.slice(0, historyStep);
      history.push(JSON.parse(JSON.stringify(objects)));
      if(history.length > 50) {
        history.shift();
        historyStep--;
      }
    }

    function undo() {
      if(historyStep > 0) {
        historyStep--;
        objects = JSON.parse(JSON.stringify(history[historyStep]));
        selectedObject = null;
        selectedObjectIndex = -1;
        redraw();
      }
    }

    function redo() {
      if(historyStep < history.length - 1) {
        historyStep++;
        objects = JSON.parse(JSON.stringify(history[historyStep]));
        selectedObject = null;
        selectedObjectIndex = -1;
        redraw();
      }
    }

    // ===== ZOOM =====
    function zoomIn() {
      zoom = Math.min(3, zoom * 1.2);
      updateZoomTransform();
      redraw();
    }

    function zoomOut() {
      zoom = Math.max(0.5, zoom / 1.2);
      updateZoomTransform();
      redraw();
    }

    // ===== SALVAR/CARREGAR =====
    function saveBoard() {
      const stickyNotes = Array.from(document.querySelectorAll('.sticky-note')).map(s => ({
        left: s.style.left,
        top: s.style.top,
        background: s.style.background,
        text: s.querySelector('textarea').value
      }));

      const mindmapNodesData = Array.from(document.querySelectorAll('.mindmap-node')).map(n => ({
        left: n.style.left,
        top: n.style.top,
        text: n.querySelector('.mindmap-text').innerText,
        isRoot: n.classList.contains('root'),
        borderColor: n.style.borderColor,
        nodeId: n.dataset.nodeId
      }));

      const imagesData = Array.from(document.querySelectorAll('.board-image')).map(img => ({
        left: img.style.left,
        top: img.style.top,
        width: img.style.width,
        height: img.style.height,
        src: img.querySelector('img').src
      }));

      const data = {
        objects: objects,
        stickyNotes: stickyNotes,
        mindmapNodes: mindmapNodesData,
        mindmapConnections: mindmapConnections,
        images: imagesData,
        zoom: zoom,
        panX: panX,
        panY: panY
      };

      localStorage.setItem('ideaboard_data', JSON.stringify(data));
      alert('‚úÖ Quadro salvo com sucesso!');
    }

    function loadBoard() {
      const data = JSON.parse(localStorage.getItem('ideaboard_data'));
      if(!data) {
        alert('‚ùå Nenhum quadro salvo encontrado!');
        return;
      }

      clearAll(false);

      objects = data.objects || [];
      zoom = data.zoom || 1;
      panX = data.panX || 0;
      panY = data.panY || 0;
      mindmapConnections = data.mindmapConnections || [];

      if(data.stickyNotes) {
        data.stickyNotes.forEach(s => {
          const sticky = document.createElement('div');
          sticky.className = 'sticky-note';
          sticky.style.left = s.left;
          sticky.style.top = s.top;
          sticky.style.background = s.background;
          sticky.style.zIndex = 100 + stickyNoteCount++;
          sticky.style.transform = `scale(${zoom})`;

          const textarea = document.createElement('textarea');
          textarea.value = s.text;
          sticky.appendChild(textarea);

          const deleteBtn = document.createElement('div');
          deleteBtn.className = 'sticky-delete';
          deleteBtn.innerHTML = '√ó';
          deleteBtn.onclick = () => sticky.remove();
          sticky.appendChild(deleteBtn);

          makeDraggable(sticky);
          container.appendChild(sticky);
        });
      }

      if(data.images) {
        data.images.forEach(imgData => {
          createBoardImage(imgData.src, parseInt(imgData.left), parseInt(imgData.top), 
                          parseInt(imgData.width) || 300, parseInt(imgData.height) || 300);
        });
      }

      if(data.mindmapNodes) {
        data.mindmapNodes.forEach((n, i) => {
          const node = document.createElement('div');
          node.className = 'mindmap-node ' + (n.isRoot ? 'root' : 'child');
          node.style.left = n.left;
          node.style.top = n.top;
          node.style.zIndex = 100 + i;
          node.style.transform = `scale(${zoom})`;
          node.dataset.nodeId = n.nodeId;
          if(n.borderColor) node.style.borderColor = n.borderColor;
          
          const textSpan = document.createElement('span');
          textSpan.className = 'mindmap-text';
          textSpan.contentEditable = true;
          textSpan.innerText = n.text;
          node.appendChild(textSpan);

          const controls = document.createElement('div');
          controls.className = 'mindmap-controls';
          
          const colorBtn = document.createElement('div');
          colorBtn.className = 'mindmap-btn mindmap-color';
          colorBtn.innerHTML = 'üé®';
          colorBtn.onclick = (e) => {
            e.stopPropagation();
            const color = nodeColors[Math.floor(Math.random() * nodeColors.length)];
            node.style.borderColor = color;
            drawMindmapConnections();
          };
          
          const connectBtn = document.createElement('div');
          connectBtn.className = 'mindmap-btn mindmap-connect';
          connectBtn.innerHTML = 'üîó';
          connectBtn.onclick = (e) => {
            e.stopPropagation();
            if(!isConnecting) {
              isConnecting = true;
              connectingFrom = node.dataset.nodeId;
              connectBtn.style.background = '#ef4444';
              alert('Clique no bot√£o üîó de outro n√≥ para criar a conex√£o');
            } else {
              if(connectingFrom !== node.dataset.nodeId) {
                mindmapConnections.push({ from: connectingFrom, to: node.dataset.nodeId });
                drawMindmapConnections();
              }
              isConnecting = false;
              connectingFrom = null;
              document.querySelectorAll('.mindmap-connect').forEach(btn => {
                btn.style.background = '#10b981';
              });
            }
          };
          
          const disconnectBtn = document.createElement('div');
          disconnectBtn.className = 'mindmap-btn mindmap-disconnect';
          disconnectBtn.innerHTML = '‚ö†Ô∏è';
          disconnectBtn.onclick = (e) => {
            e.stopPropagation();
            mindmapConnections = mindmapConnections.filter(c => 
              c.from !== node.dataset.nodeId && c.to !== node.dataset.nodeId
            );
            drawMindmapConnections();
          };
          
          const deleteBtn = document.createElement('div');
          deleteBtn.className = 'mindmap-btn mindmap-delete';
          deleteBtn.innerHTML = '√ó';
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            const index = mindmapNodes.indexOf(node);
            if(index > -1) {
              mindmapNodes.splice(index, 1);
              mindmapConnections = mindmapConnections.filter(c => 
                c.from !== node.dataset.nodeId && c.to !== node.dataset.nodeId
              );
              drawMindmapConnections();
            }
            node.remove();
          };
          
          controls.appendChild(colorBtn);
          controls.appendChild(connectBtn);
          controls.appendChild(disconnectBtn);
          controls.appendChild(deleteBtn);
          node.appendChild(controls);

          makeDraggable(node, () => drawMindmapConnections());
          container.appendChild(node);
          mindmapNodes.push(node);
        });
      }

      updateZoomTransform();
      addToHistory();
      redraw();
      drawMindmapConnections();
      alert('‚úÖ Quadro carregado com sucesso!');
    }

    function exportImage() {
      const link = document.createElement('a');
      link.download = 'ideaboard_' + Date.now() + '.png';
      link.href = canvas.toDataURL();
      link.click();
      alert('‚úÖ Imagem exportada com sucesso!');
    }

    function clearAll(confirm = true) {
      if(confirm && !window.confirm('‚ö†Ô∏è Tem certeza que deseja limpar tudo?')) return;
      
      objects = [];
      history = [];
      historyStep = -1;
      zoom = 1;
      panX = 0;
      panY = 0;
      selectedObject = null;
      selectedObjectIndex = -1;
      
      document.querySelectorAll('.sticky-note').forEach(s => s.remove());
      document.querySelectorAll('.mindmap-node').forEach(n => n.remove());
      document.querySelectorAll('.board-image').forEach(img => img.remove());
      
      stickyNoteCount = 0;
      mindmapNodes = [];
      mindmapConnections = [];
      boardImages = [];
      
      connectionsSvg.innerHTML = '';
      
      addToHistory();
      redraw();
    }

    // ===== INICIAR =====
    init();
  </script>
</body>
</html>

